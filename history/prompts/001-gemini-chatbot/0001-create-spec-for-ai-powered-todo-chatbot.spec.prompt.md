---
id: 0001
title: Create Spec for AI-Powered Todo Chatbot
stage: spec
date: 2026-02-08
surface: agent
model: gemini-1.5-pro
feature: 001-gemini-chatbot
branch: 001-gemini-chatbot
user: sufi
command: |
  Specification: Phase III - AI-Powered Todo Chatbot (Gemini Edition)1. Executive SummaryThis specification defines the requirements for Phase III, which adds a conversational interface to the existing Todo application. The system will use Google Gemini via the google-generativeai SDK. The architecture adheres to the Model Context Protocol (MCP) pattern, where the AI operates strictly as a reasoner that invokes defined "Tools" (Agent Skills) to manipulate the Phase II backend.2. Core Constraints (The Constitution)Immutable Phase II: The existing tasks table, auth logic, and CRUD services must not be rewritten.Stateless Server: The chat endpoint must be stateless. Conversation history is hydrated from the DB on every request.Single Entry Point: All interactions occur via POST /api/v1/chat.Tool-First Intelligence: The AI cannot access the DB directly; it must use the defined tools (add_task, list_tasks, etc.).3. Data Model Specification3.1 Existing (ReadOnly)Table: User (Managed by Auth system)Table: Taskid (int, pk)title (str)description (str, nullable)is_completed (bool)user_id (str, fk)3.2 New Tables (To Be Created)The chat history must be persisted to support stateless interactions.Table: conversationsid (UUID or BigInt, Primary Key)user_id (String, Foreign Key -> users.id, Indexed)title (String, nullable) - Auto-generated summary of the chat.created_at (DateTime, Default: Now)updated_at (DateTime, Default: Now)Table: messagesid (UUID or BigInt, Primary Key)conversation_id (UUID/BigInt, Foreign Key -> conversations.id, Indexed)role (Enum/String): ['user', 'model', 'tool'] - Strictly maps to Gemini API roles.content (Text/JSON): Stores the prompt, the response, or the tool output.tool_call_id (String, nullable): Links tool results to tool calls (if required by logic).created_at (DateTime, Default: Now)4. Agent Skills (Tool Definitions)The "Intelligence" layer is defined by the tools available to the LLM. These must be implemented as Python functions and bound to the Gemini Chat Session.Skill NameDescriptionParameters (JSON Schema)Expected Outputadd_taskAdds a new task to the user's list.{ "content": "string" } (Description is optional, merged into content){ "id": 1, "status": "created", "task": {...} }list_tasksFetches tasks based on status.{ "status": "pending" | "completed" | "all" }[ { "id": 1, "content": "...", "is_completed": false } ]update_taskUpdates title or description.{ "task_id": int, "content": "string" }{ "id": 1, "status": "updated" }complete_taskMarks a task as done.{ "task_id": int }{ "id": 1, "status": "completed" }delete_taskPermanently removes a task.{ "task_id": int }{ "id": 1, "status": "deleted" }get_current_timeHelper to understand "today/tomorrow".{}{ "iso_time": "2024-05-20T10:00:00Z" }5. API SpecificationEndpoint: POST /api/v1/chats/{conversation_id}/messagesDescription: The single funnel for the ReAct loop.Path Params: conversation_id (if new, client generates UUID or requests generic /chat to create one).Headers: Authorization: Bearer <token>Request Body:JSON{ "content": "I need to buy milk tomorrow" } Response Body:JSON{ "message": { "role": "model", "content": "I've added 'Buy milk' to your list for tomorrow." }, "tool_activity": [ ... ] // Optional: For debugging/UI feedback } 6. Functional Scenarios (Gherkin)Scenario 1: Create a Task (Happy Path)GherkinGiven I am an authenticated user And I have an empty task list When I send the message "Remind me to submit the report" Then the system should invoke the `add_task` tool with content "Submit the report" And the database should contain a new task "Submit the report" And the response should be "I've added 'Submit the report' to your tasks." Scenario 2: List Pending TasksGherkinGiven I have 2 pending tasks ("Buy Milk", "Walk Dog") And I have 1 completed task ("Sleep") When I send the message "What do I have left to do?" Then the system should invoke `list_tasks` with argument `status="pending"` And the response should contain "Buy Milk" and "Walk Dog" And the response should NOT contain "Sleep" Scenario 3: Contextual Update (Multi-turn)GherkinGiven I am in an active conversation When I send "Add a task to call John" And the agent confirms the addition When I send "Actually, change that to Call John Doe" Then the system should identify the task ID of "Call John" from the conversation history And the system should invoke `update_task` with that ID and content "Call John Doe" And the response should confirm the update. Scenario 4: Delete with Ambiguity (Safety)GherkinGiven I have two tasks: "Buy Red Paint" and "Buy Red Tape" When I send "Delete the red one" Then the system should NOT invoke `delete_task` And the response should ask for clarification: "Did you mean 'Buy Red Paint' or 'Buy Red Tape'?" Scenario 5: Delete with ConfirmationGherkinGiven I have a task "Cancel Subscription" When I send "Delete the subscription task" Then the system should invoke `delete_task` And the response should explicitly state: "I have deleted the task: Cancel Subscription" 7. Implementation Guidelines (Gemini Specific)7.1 The ReAct Loop LogicSince we are not using LangChain or OpenAI Assistants, the controller must implement the loop manually:Load: history = db.get_messages(conversation_id)Predict: response = gemini.generate_content(history + new_msg, tools=[skills])Check: Does response contain a function_call?YES:Parse function name and args.Call local Python function (e.g., TodoService.add_task(...)).Construct a FunctionResponse part.Append FunctionResponse to history.GOTO Step 2 (Recursion with new info).NO:Return response.text to user.Save all new turns to messages table.7.2 Security BarriersUser Isolation: The user_id from the JWT token must be injected into every Tool call. The Agent must never be allowed to pass a user_id as an argument. The Tool implementation must hard-override the user_id with the authenticated user's ID.8. Development Phases (Checklist)[ ] DB Migration: Create conversations and messages tables.[ ] Tool Wrapping: Create app/utils/skills.py wrapping Phase II services.[ ] Gemini Client: Initialize GenAI client with API Key.[ ] Chat Service: Implement the ReAct Loop (The "Engine").[ ] API Layer: Expose the endpoint and connect Auth.[ ] Testing: Verify Scenarios 1-5 manually or via integration tests.Specification: Phase III - AI-Powered Todo Chatbot (Gemini Edition)1. Executive SummaryThis specification defines the requirements for Phase III, which adds a conversational interface to the existing Todo application. The system will use Google Gemini via the google-generativeai SDK. The architecture adheres to the Model Context Protocol (MCP) pattern, where the AI operates strictly as a reasoner that invokes defined "Tools" (Agent Skills) to manipulate the Phase II backend.2. Core Constraints (The Constitution)Immutable Phase II: The existing tasks table, auth logic, and CRUD services must not be rewritten.Stateless Server: The chat endpoint must be stateless. Conversation history is hydrated from the DB on every request.Single Entry Point: All interactions occur via POST /api/v1/chat.Tool-First Intelligence: The AI cannot access the DB directly; it must use the defined tools (add_task, list_tasks, etc.).3. Data Model Specification3.1 Existing (ReadOnly)Table: User (Managed by Auth system)Table: Taskid (int, pk)title (str)description (str, nullable)is_completed (bool)user_id (str, fk)3.2 New Tables (To Be Created)The chat history must be persisted to support stateless interactions.Table: conversationsid (UUID or BigInt, Primary Key)user_id (String, Foreign Key -> users.id, Indexed)title (String, nullable) - Auto-generated summary of the chat.created_at (DateTime, Default: Now)updated_at (DateTime, Default: Now)Table: messagesid (UUID or BigInt, Primary Key)conversation_id (UUID/BigInt, Foreign Key -> conversations.id, Indexed)role (Enum/String): ['user', 'model', 'tool'] - Strictly maps to Gemini API roles.content (Text/JSON): Stores the prompt, the response, or the tool output.tool_call_id (String, nullable): Links tool results to tool calls (if required by logic).created_at (DateTime, Default: Now)4. Agent Skills (Tool Definitions)The "Intelligence" layer is defined by the tools available to the LLM. These must be implemented as Python functions and bound to the Gemini Chat Session.Skill NameDescriptionParameters (JSON Schema)Expected Outputadd_taskAdds a new task to the user's list.{ "content": "string" } (Description is optional, merged into content){ "id": 1, "status": "created", "task": {...} }list_tasksFetches tasks based on status.{ "status": "pending" | "completed" | "all" }[ { "id": 1, "content": "...", "is_completed": false } ]update_taskUpdates title or description.{ "task_id": int, "content": "string" }{ "id": 1, "status": "updated" }complete_taskMarks a task as done.{ "task_id": int }{ "id": 1, "status": "completed" }delete_taskPermanently removes a task.{ "task_id": int }{ "id": 1, "status": "deleted" }get_current_timeHelper to understand "today/tomorrow".{}{ "iso_time": "2024-05-20T10:00:00Z" }5. API SpecificationEndpoint: POST /api/v1/chats/{conversation_id}/messagesDescription: The single funnel for the ReAct loop.Path Params: conversation_id (if new, client generates UUID or requests generic /chat to create one).Headers: Authorization: Bearer <token>Request Body:JSON{ "content": "I need to buy milk tomorrow" } Response Body:JSON{ "message": { "role": "model", "content": "I've added 'Buy milk' to your list for tomorrow." }, "tool_activity": [ ... ] // Optional: For debugging/UI feedback } 6. Functional Scenarios (Gherkin)Scenario 1: Create a Task (Happy Path)GherkinGiven I am an authenticated user And I have an empty task list When I send the message "Remind me to submit the report" Then the system should invoke the `add_task` tool with content "Submit the report" And the database should contain a new task "Submit the report" And the response should be "I've added 'Submit the report' to your tasks." Scenario 2: List Pending TasksGherkinGiven I have 2 pending tasks ("Buy Milk", "Walk Dog") And I have 1 completed task ("Sleep") When I send the message "What do I have left to do?" Then the system should invoke `list_tasks` with argument `status="pending"` And the response should contain "Buy Milk" and "Walk Dog" And the response should NOT contain "Sleep" Scenario 3: Contextual Update (Multi-turn)GherkinGiven I am in an active conversation When I send "Add a task to call John" And the agent confirms the addition When I send "Actually, change that to Call John Doe" Then the system should identify the task ID of "Call John" from the conversation history And the system should invoke `update_task` with that ID and content "Call John Doe" And the response should confirm the update. Scenario 4: Delete with Ambiguity (Safety)GherkinGiven I have two tasks: "Buy Red Paint" and "Buy Red Tape" When I send "Delete the red one" Then the system should NOT invoke `delete_task` And the response should ask for clarification: "Did you mean 'Buy Red Paint' or 'Buy Red Tape'?" Scenario 5: Delete with ConfirmationGherkinGiven I have a task "Cancel Subscription" When I send "Delete the subscription task" Then the system should invoke `delete_task` And the response should explicitly state: "I have deleted the task: Cancel Subscription" 7. Implementation Guidelines (Gemini Specific)7.1 The ReAct Loop LogicSince we are not using LangChain or OpenAI Assistants, the controller must implement the loop manually:Load: history = db.get_messages(conversation_id)Predict: response = gemini.generate_content(history + new_msg, tools=[skills])Check: Does response contain a function_call?YES:Parse function name and args.Call local Python function (e.g., TodoService.add_task(...)).Construct a FunctionResponse part.Append FunctionResponse to history.GOTO Step 2 (Recursion with new info).NO:Return response.text to user.Save all new turns to messages table.7.2 Security BarriersUser Isolation: The user_id from the JWT token must be injected into every Tool call. The Agent must never be allowed to pass a user_id as an argument. The Tool implementation must hard-override the user_id with the authenticated user's ID.8. Development Phases (Checklist)[ ] DB Migration: Create conversations and messages tables.[ ] Tool Wrapping: Create app/utils/skills.py wrapping Phase II services.[ ] Gemini Client: Initialize GenAI client with API Key.[ ] Chat Service: Implement the ReAct Loop (The "Engine").[ ] API Layer: Expose the endpoint and connect Auth.[ ] Testing: Verify Scenarios 1-5 manually or via integration tests.Specification: Phase III - AI-Powered Todo Chatbot (Gemini Edition)1. Executive SummaryThis specification defines the requirements for Phase III, which adds a conversational interface to the existing Todo application. The system will use Google Gemini via the google-generativeai SDK. The architecture adheres to the Model Context Protocol (MCP) pattern, where the AI operates strictly as a reasoner that invokes defined "Tools" (Agent Skills) to manipulate the Phase II backend.2. Core Constraints (The Constitution)Immutable Phase II: The existing tasks table, auth logic, and CRUD services must not be rewritten.Stateless Server: The chat endpoint must be stateless. Conversation history is hydrated from the DB on every request.Single Entry Point: All interactions occur via POST /api/v1/chat.Tool-First Intelligence: The AI cannot access the DB directly; it must use the defined tools (add_task, list_tasks, etc.).3. Data Model Specification3.1 Existing (ReadOnly)Table: User (Managed by Auth system)Table: Taskid (int, pk)title (str)description (str, nullable)is_completed (bool)user_id (str, fk)3.2 New Tables (To Be Created)The chat history must be persisted to support stateless interactions.Table: conversationsid (UUID or BigInt, Primary Key)user_id (String, Foreign Key -> users.id, Indexed)title (String, nullable) - Auto-generated summary of the chat.created_at (DateTime, Default: Now)updated_at (DateTime, Default: Now)Table: messagesid (UUID or BigInt, Primary Key)conversation_id (UUID/BigInt, Foreign Key -> conversations.id, Indexed)role (Enum/String): ['user', 'model', 'tool'] - Strictly maps to Gemini API roles.content (Text/JSON): Stores the prompt, the response, or the tool output.tool_call_id (String, nullable): Links tool results to tool calls (if required by logic).created_at (DateTime, Default: Now)4. Agent Skills (Tool Definitions)The "Intelligence" layer is defined by the tools available to the LLM. These must be implemented as Python functions and bound to the Gemini Chat Session.Skill NameDescriptionParameters (JSON Schema)Expected Outputadd_taskAdds a new task to the user's list.{ "content": "string" } (Description is optional, merged into content){ "id": 1, "status": "created", "task": {...} }list_tasksFetches tasks based on status.{ "status": "pending" | "completed" | "all" }[ { "id": 1, "content": "...", "is_completed": false } ]update_taskUpdates title or description.{ "task_id": int, "content": "string" }{ "id": 1, "status": "updated" }complete_taskMarks a task as done.{ "task_id": int }{ "id": 1, "status": "completed" }delete_taskPermanently removes a task.{ "task_id": int }{ "id": 1, "status": "deleted" }get_current_timeHelper to understand "today/tomorrow".{}{ "iso_time": "2024-05-20T10:00:00Z" }5. API SpecificationEndpoint: POST /api/v1/chats/{conversation_id}/messagesDescription: The single funnel for the ReAct loop.Path Params: conversation_id (if new, client generates UUID or requests generic /chat to create one).Headers: Authorization: Bearer <token>Request Body:JSON{ "content": "I need to buy milk tomorrow" } Response Body:JSON{ "message": { "role": "model", "content": "I've added 'Buy milk' to your list for tomorrow." }, "tool_activity": [ ... ] // Optional: For debugging/UI feedback } 6. Functional Scenarios (Gherkin)Scenario 1: Create a Task (Happy Path)GherkinGiven I am an authenticated user And I have an empty task list When I send the message "Remind me to submit the report" Then the system should invoke the `add_task` tool with content "Submit the report" And the database should contain a new task "Submit the report" And the response should be "I've added 'Submit the report' to your tasks." Scenario 2: List Pending TasksGherkinGiven I have 2 pending tasks ("Buy Milk", "Walk Dog") And I have 1 completed task ("Sleep") When I send the message "What do I have left to do?" Then the system should invoke `list_tasks` with argument `status="pending"` And the response should contain "Buy Milk" and "Walk Dog" And the response should NOT contain "Sleep" Scenario 3: Contextual Update (Multi-turn)GherkinGiven I am in an active conversation When I send "Add a task to call John" And the agent confirms the addition When I send "Actually, change that to Call John Doe" Then the system should identify the task ID of "Call John" from the conversation history And the system should invoke `update_task` with that ID and content "Call John Doe" And the response should confirm the update. Scenario 4: Delete with Ambiguity (Safety)GherkinGiven I have two tasks: "Buy Red Paint" and "Buy Red Tape" When I send "Delete the red one" Then the system should NOT invoke `delete_task` And the response should ask for clarification: "Did you mean 'Buy Red Paint' or 'Buy Red Tape'?" Scenario 5: Delete with ConfirmationGherkinGiven I have a task "Cancel Subscription" When I send "Delete the subscription task" Then the system should invoke `delete_task` And the response should explicitly state: "I have deleted the task: Cancel Subscription" 7. Implementation Guidelines (Gemini Specific)7.1 The ReAct Loop LogicSince we are not using LangChain or OpenAI Assistants, the controller must implement the loop manually:Load: history = db.get_messages(conversation_id)Predict: response = gemini.generate_content(history + new_msg, tools=[skills])Check: Does response contain a function_call?YES:Parse function name and args.Call local Python function (e.g., TodoService.add_task(...)).Construct a FunctionResponse part.Append FunctionResponse to history.GOTO Step 2 (Recursion with new info).NO:Return response.text to user.Save all new turns to messages table.7.2 Security BarriersUser Isolation: The user_id from the JWT token must be injected into every Tool call. The Agent must never be allowed to pass a user_id as an argument. The Tool implementation must hard-override the user_id with the authenticated user's ID.8. Development Phases (Checklist)[ ] DB Migration: Create conversations and messages tables.[ ] Tool Wrapping: Create app/utils/skills.py wrapping Phase II services.[ ] Gemini Client: Initialize GenAI client with API Key.[ ] Chat Service: Implement the ReAct Loop (The "Engine").[ ] API Layer: Expose the endpoint and connect Auth.[ ] Testing: Verify Scenarios 1-5 manually or via integration tests.`